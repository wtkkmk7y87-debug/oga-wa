<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>画像地図 × GPSナビ（完成版）</title>

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<!-- 行列計算 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>

<style>
html, body {
  height: 100%;
  margin: 0;
}
#map {
  width: 100%;
  height: 100%;
}

/* 状態表示（元の位置：左下） */
#status {
  position: fixed;
  left: 15px;
  bottom: 15px;
  z-index: 1000;
  background: rgba(0,0,0,0.8);
  color: white;
  padding: 10px 14px;
  border-radius: 8px;
  display: none;
  font-size: 14px;
}
</style>
</head>

<body>
<div id="status"></div>
<div id="map"></div>

<script>
/* ===============================
① 画像サイズ
================================ */
const imageWidth  = 3312;
const imageHeight = 3392;

/* ===============================
② 対応点（キャリブレーション）
================================ */
const controlPoints = [
  { img:{x:179,  y:1211}, gps:{lat:35.640376, lng:139.294706} },
  { img:{x:2894, y:697},  gps:{lat:35.641230, lng:139.300170} },
  { img:{x:140,  y:2262}, gps:{lat:35.638620, lng:139.294578} },
  { img:{x:3239,y:2442}, gps:{lat:35.638278, lng:139.300813} }
];

/* ===============================
③ アフィン変換
================================ */
function computeAffine(points) {
  let A = [], B = [];
  points.forEach(p => {
    const lng = p.gps.lng;
    const lat = -p.gps.lat;
    A.push([lng, lat, 1, 0, 0, 0]);
    A.push([0, 0, 0, lng, lat, 1]);
    B.push(p.img.x);
    B.push(p.img.y);
  });
  const AT = math.transpose(A);
  const X = math.multiply(
    math.inv(math.multiply(AT, A)),
    math.multiply(AT, B)
  );
  return { a:X[0], b:X[1], c:X[2], d:X[3], e:X[4], f:X[5] };
}
const affine = computeAffine(controlPoints);

/* ===============================
④ GPS → 画像座標（Y反転）
================================ */
function gpsToImage(lat, lng) {
  lat = -lat;
  const x = affine.a * lng + affine.b * lat + affine.c;
  const y = affine.d * lng + affine.e * lat + affine.f;
  return { x, y: imageHeight - y };
}

/* ===============================
⑤ Leaflet 初期化
================================ */
const map = L.map("map", {
  crs: L.CRS.Simple,
  minZoom: -2,
  maxZoom: 2
});
const bounds = [[0,0],[imageHeight,imageWidth]];
L.imageOverlay("map.jpg", bounds).addTo(map);
map.fitBounds(bounds);

/* ===============================
⑥ アイコン（ズーム補正対応）
================================ */
const CURRENT_ICON_SIZE = [40, 40];
const GOAL_ICON_SIZE = [48, 48];

function createCurrentIcon(scale = 1) {
  return L.icon({
    iconUrl: "current.png",
    iconSize: [
      CURRENT_ICON_SIZE[0] * scale,
      CURRENT_ICON_SIZE[1] * scale
    ],
    iconAnchor: [
      (CURRENT_ICON_SIZE[0] * scale) / 2,
      CURRENT_ICON_SIZE[1] * scale
    ]
  });
}

function createGoalIcon(scale = 1) {
  return L.icon({
    iconUrl: "goal.png",
    iconSize: [
      GOAL_ICON_SIZE[0] * scale,
      GOAL_ICON_SIZE[1] * scale
    ],
    iconAnchor: [
      (GOAL_ICON_SIZE[0] * scale) / 2,
      GOAL_ICON_SIZE[1] * scale
    ]
  });
}

let currentIcon = createCurrentIcon(1);
let goalIcon = createGoalIcon(1);

/* ===============================
⑦ レイヤー管理
================================ */
let currentMarker = null;
let goalMarker = null;
let accuracyCircle = null;
let routeLine = null;

const status = document.getElementById("status");
const meterToPixel = 1.2;

/* ===============================
⑧ GPS（自動開始）
================================ */
navigator.geolocation.watchPosition(
  pos => {
    const { latitude, longitude, accuracy } = pos.coords;
    const p = gpsToImage(latitude, longitude);

    if (
      p.x < 0 || p.x > imageWidth ||
      p.y < 0 || p.y > imageHeight
    ) {
      status.textContent = "現在地は範囲外です";
      status.style.display = "block";
      return;
    }

    status.style.display = "none";
    const ll = L.latLng(p.y, p.x);

    /* 現在地 */
    if (!currentMarker) {
      currentMarker = L.marker(ll, { icon: currentIcon }).addTo(map);
    } else {
      currentMarker.setLatLng(ll);
    }

    /* 精度円 */
    const radiusPx = accuracy * meterToPixel;
    if (!accuracyCircle) {
      accuracyCircle = L.circle(ll, {
        radius: radiusPx,
        color: "blue",
        weight: 1,
        fillColor: "blue",
        fillOpacity: 0.15
      }).addTo(map);
    } else {
      accuracyCircle.setLatLng(ll);
      accuracyCircle.setRadius(radiusPx);
    }

    /* 直線 */
    if (goalMarker) {
      drawRoute(currentMarker.getLatLng(), goalMarker.getLatLng());
    }
  },
  err => alert(err.message),
  { enableHighAccuracy: true }
);

/* ===============================
⑨ 目的地（クリック）
================================ */
map.on("click", e => {
  if (goalMarker) map.removeLayer(goalMarker);
  goalMarker = L.marker(e.latlng, { icon: goalIcon }).addTo(map);

  if (currentMarker) {
    drawRoute(currentMarker.getLatLng(), goalMarker.getLatLng());
  }
});

/* ===============================
⑩ 現在地〜目的地の直線
================================ */
function drawRoute(from, to) {
  if (!routeLine) {
    routeLine = L.polyline([from, to], {
      color: "orange",
      weight: 4,
      dashArray: "6,6"
    }).addTo(map);
  } else {
    routeLine.setLatLngs([from, to]);
  }
}

/* ===============================
⑪ ズームしても旗サイズ固定
================================ */
map.on("zoomend", () => {
  const zoom = map.getZoom();
  const scale = Math.pow(2, -zoom);

  currentIcon = createCurrentIcon(scale);
  goalIcon = createGoalIcon(scale);

  if (currentMarker) currentMarker.setIcon(currentIcon);
  if (goalMarker) goalMarker.setIcon(goalIcon);
});
</script>
</body>
</html>
